function[q] = integrateOdom( qInit , d, phi)
% takes in odom and pose and outtputs future pose
%
% INPUTS
%       qInit      	3-by-1 pose vector in global coordinates (x,y,theta)
%       d         	    list of distances robot will travel 1-by-K vector
%       phi          	list of angles robot will turn 1-by-K vector
%
% OUTPUTS
%       q           Robot pose after odometry


% init variables
n = length(d); % length of input data
q = zeros(3,n); % Evolution of robot's configuration 3x1 [x y theta]'
q = [qInit,q];

% Initial configuration
x = q(1,1); y = q(2,1); theta = q(3,1);

for i = 1:n % Iterate through all distances and angles
    
    % Current distance and angle measurements
    currD = d(i); 
    currPhi = phi(i);
    
    if (currPhi)==0 % If phi is zero
        
        % Find displacements given info above
        dx = currD*cos(theta);
        dy = currD*sin(theta);
        dtheta = currPhi;
        
        % Current Configuration
        x = x + dx; 
        y = y + dy; 
        theta = theta + dtheta;
        q(:,i+1) = [x;y;theta];
        
    else % If phi is non zero
        % Find displacements given info above
        dx = 2*currD/currPhi*sin(currPhi/2)*cos(currPhi/2 + theta);
        dy = 2*currD/currPhi*sin(currPhi/2)*sin(currPhi/2 + theta);
        dtheta = currPhi;
        
        % Current Configuration
        x = x + dx; y = y + dy; theta = theta + dtheta;
        q(:,i+1) = [x;y;theta];
    end
end
q = q(:,2:end);

